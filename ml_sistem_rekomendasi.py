# -*- coding: utf-8 -*-
"""ML-Sistem Rekomendasi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Al01O1zlFrRaT4u1woO_AAUyUOdeyKw1

# Data Loading

Melakukan load terhadap dataset dan import pada library yang dibutuhkan
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

netflix = pd.read_csv('/content/netflix_titles.csv')
netflix

"""Load dataset ke dalam variabel

# Exploratory Data Analysis
"""

netflix.info()

"""Dataset ini terdiri dari 12 kolom sebagai berikut:

1. **show_id**: ID unik untuk masing-masing film atau acara TV.
2. **type**: Jenis konten, apakah itu Film (Movie) atau Acara TV (TV Show).
3. **title**: Judul film atau acara TV.
4. **director**: Nama sutradara atau pembuat acara.
5. **cast**: Nama-nama pemeran utama atau tokoh dalam film atau acara TV.
6. **country**: Negara asal produksi film atau acara TV.
7. **date_added**: Tanggal ketika konten tersebut ditambahkan ke platform Netflix.
8. **release_year**: Tahun rilis film atau acara TV tersebut.
9. **rating**: Rating yang diberikan untuk film atau acara TV tersebut (misalnya, PG-13, TV-MA, dll.).
10. **duration**: Durasi film atau jumlah musim untuk acara TV.
11. **listed_in**: Kategori atau genre konten tersebut, seperti Drama, Aksi, Komedi, dll.
12. **description**: Deskripsi singkat mengenai alur cerita atau tema dari film atau acara TV.

"""

print('Jumlah judul film: ', len(netflix.title.unique()))

"""Jumlah data pada dataset ini ada 8807

## Univariate Analysis
"""

plt.figure(figsize=(12, 6))  # Lebar 12 dan tinggi 6

# Histogram untuk distribusi rating
sns.histplot(netflix['rating'], kde=True, bins=10)
plt.title('Distribusi Rating')
plt.xlabel('Rating')
plt.ylabel('Frekuensi')
plt.show()

"""**Insight:**

- **Rating PG dan TV-14**: Memiliki frekuensi tertinggi, menunjukkan popularitas yang signifikan.
- **Rating TV-MA**: Juga cukup tinggi, menandakan minat pada konten dewasa.
- **Rating R**: Menunjukkan frekuensi yang lebih rendah dibandingkan PG dan TV-14, tetapi masih relevan.
- **Rating lainnya (TV-PG, TV-Y, dll.)**: Memiliki frekuensi yang jauh lebih rendah, menunjukkan kurangnya popularitas.
- **Distribusi**: Terdapat puncak yang jelas pada beberapa rating, menunjukkan preferensi pemirsa yang kuat terhadap kategori tertentu.

"""

# Menghitung jumlah film per genre
genre_counts = netflix['listed_in'].value_counts()

# Mengambil 10 genre teratas
top_genres = genre_counts.head(10)

plt.figure(figsize=(12, 6))  # Lebar 20 dan tinggi 6
# Barplot untuk distribusi genre teratas
sns.barplot(x=top_genres.index, y=top_genres.values)
plt.title('Distribusi 10 Genre Film Teratas')
plt.xticks(rotation=90)
plt.xlabel('Genre')
plt.ylabel('Jumlah Film')
plt.show()

"""**Insight:**

1. **Dominasi Drama Internasional**: Genre "Dramas, International Movies" mendominasi dengan jumlah film tertinggi, mencapai lebih dari 350 entri. Ini menunjukkan bahwa film drama internasional sangat diminati oleh penonton.

2. **Minat pada Dokumenter**: Genre dokumenter juga menunjukkan jumlah yang signifikan, dengan lebih dari 300 film. Ini mencerminkan ketertarikan penonton terhadap konten yang informatif dan berbasis fakta.

3. **Daya Tarik Stand-Up Comedy**: Genre "Stand-Up Comedy" memiliki jumlah film yang cukup tinggi, menunjukkan bahwa hiburan komedi, terutama dalam format stand-up, sangat populer di kalangan penonton.

4. **Keseimbangan Genre Keluarga**: Genre "Children & Family Movies" dan "Kids' TV" menunjukkan bahwa film dan program untuk anak-anak dan keluarga memiliki pangsa pasar yang besar, menandakan pentingnya konten yang ramah keluarga.

5. **Variasi dalam Genre**: Terdapat variasi dalam genre yang ditampilkan, termasuk komedi dan film independen, menunjukkan keberagaman dalam pilihan film yang tersedia untuk penonton.


"""

# Menghitung jumlah genre unik
unique_genres = netflix['listed_in'].unique()
num_genres = len(unique_genres)

# Menampilkan hasil
print('Banyak genre film: ', num_genres)
print('Genre film: ', unique_genres)

"""Daftar Jumlah Genre dan Genre dari film yang ada pada dataset"""

# Histogram untuk distribusi tahun rilis film
sns.histplot(netflix['release_year'], kde=True, bins=20)
plt.title('Distribusi Tahun Rilis Film')
plt.xlabel('Tahun Rilis')
plt.ylabel('Jumlah Film')
plt.show()

"""**Insight:**

- **Peningkatan Drastis**: Terjadi lonjakan signifikan dalam jumlah film yang dirilis mulai tahun 2000-an, menunjukkan pertumbuhan industri film yang pesat.
- **Dominasi Tahun 2020**: Tahun 2020 mencatat jumlah film tertinggi, mungkin dipengaruhi oleh platform streaming dan produksi yang meningkat.
- **Stabilitas Sebelum 2000**: Sebelum tahun 2000, jumlah film yang dirilis relatif rendah dan stabil, menunjukkan pertumbuhan industri yang lambat.
- **Tren Modern**: Munculnya teknologi dan platform baru berkontribusi pada peningkatan jumlah film yang dirilis dalam dua dekade terakhir.

Melakukan konversi terhadap duration film yang dalam satuan season dengan 200 menit
"""

def convert_duration(duration):
    # Tambahkan penanganan untuk nilai float (NaN)
    if isinstance(duration, float):
        return None  # Atau nilai default lain yang sesuai

    if 'min' in duration:
        return int(duration.split()[0])  # Ambil angka sebelum 'min'
    elif 'season' in duration:
        return int(duration.split()[0]) * 200  # Asumsi 1 season = 200 menit
    return None  # Jika format tidak dikenali

# Terapkan fungsi konversi
netflix['duration_minutes'] = netflix['duration'].apply(convert_duration)

jumlah_data = len(netflix['duration_minutes'])
print(f"Jumlah data: {jumlah_data}")

# Histogram untuk distribusi durasi film
plt.figure(figsize=(20, 6))  # Lebar 20 dan tinggi 6
sns.histplot(netflix['duration_minutes'], kde=True, bins=20)
plt.title('Distribusi Durasi Film')
plt.xlabel('Durasi (menit)')
plt.ylabel('Frekuensi')
plt.show()

"""**Insight:**

1. **Puncak Durasi**: Mayoritas film memiliki durasi antara 80 hingga 120 menit, dengan puncak tertinggi di sekitar 100 menit. Ini menunjukkan bahwa durasi ini adalah yang paling disukai oleh pembuat film dan penonton.

2. **Frekuensi Tinggi**: Terdapat frekuensi tinggi untuk film dengan durasi di bawah 100 menit, menunjukkan bahwa film pendek lebih umum dan mungkin lebih menarik bagi penonton yang mencari pengalaman menonton yang lebih singkat.

3. **Penurunan Drastis**: Setelah 150 menit, frekuensi film menurun secara signifikan, menunjukkan bahwa film dengan durasi lebih panjang jarang diproduksi atau kurang diminati.

4. **Distribusi Normal**: Kurva distribusi menunjukkan pola yang mendekati distribusi normal, dengan sebagian besar film berkumpul di sekitar durasi rata-rata, dan sedikit film yang memiliki durasi ekstrem.

"""

# Menghitung durasi maksimum, rata-rata, dan minimum
max_duration = netflix['duration_minutes'].max()
mean_duration = netflix['duration_minutes'].mean()
min_duration = netflix['duration_minutes'].min()

# Menampilkan hasil
print(f"Durasi Maksimum: {max_duration} menit")
print(f"Durasi Rata-rata: {mean_duration:.2f} menit")
print(f"Durasi Minimum: {min_duration} menit")

"""Kode di atas digunakan untuk menghitung durasi maksimum, rata-rata, dan minimum dari kolom `duration_minutes` pada dataset Netflix. Fungsi `max()`, `mean()`, dan `min()` digunakan untuk menemukan nilai durasi tertinggi, rata-rata, dan terendah, kemudian hasilnya ditampilkan menggunakan `print()`. Hasil yang ditampilkan menunjukkan bahwa durasi maksimum adalah 312 menit, durasi rata-rata sekitar 99.58 menit, dan durasi minimum adalah 3 menit, memberikan gambaran tentang distribusi durasi film dan acara TV di Netflix.

"""

# Ringkasan statistik untuk data numerik
print(netflix.describe())

"""**Insight:**

1. **Jumlah Data**: Terdapat 8.807 film, dengan 6.128 film yang memiliki durasi.

2. **Tahun Rilis**:
   - Rata-rata tahun rilis: 2014.
   - Film tertua: 1925.
   - Film terbaru: 2021.

3. **Durasi Film**:
   - Rata-rata durasi: 99,6 menit.
   - Durasi terpendek: 3 menit.
   - Durasi terpanjang: 312 menit.
   - Variasi durasi: Standar deviasi 28,3 menit.

4. **Distribusi Durasi**:
   - 25% film di bawah 87 menit.
   - Median di bawah 98 menit.
   - 75% film di bawah 114 menit.

# Data Preparation

## Handling Missing Value
"""

netflix.isna().sum()

"""Karena ukuran dataset ini cukup besar (8807 entri), masalah nilai yang hilang dapat diatasi dengan menghapus baris yang mengandung nilai tersebut tanpa memengaruhi kualitas analisis secara signifikan. Menghapus baris dengan nilai yang hilang di kolom-kolom tersebut adalah solusi yang tepat, karena penghapusan ini tidak akan mengurangi data secara signifikan dan dataset akan tetap representatif untuk analisis berikutnya."""

netflix_clean = netflix.dropna()

netflix_clean.isna().sum()

"""melakukan cek terhadap dataset setelah dilakukan drop terhadap kolom yang null"""

netflix_clean.head()

netflix_clean.shape

"""mengecek shape dari dataset setelah dilakukan handling missing value"""

duplicate_rows = netflix_clean[netflix_clean.duplicated()]

if not duplicate_rows.empty:
    print("Duplicate Rows:")
    print(duplicate_rows)
else:
    print("No duplicate rows found.")

"""Output di atas menunjukkan bahwa tidak ada data yang memiliki entri duplikat. Ini mengindikasikan bahwa dataset yang digunakan sudah bebas dari duplikasi

# Feature Engineering
"""

rec_netflix = netflix_clean[['show_id', 'title', 'listed_in']]
rec_netflix.head()

"""Kolom-kolom yang relevan dipilih untuk digunakan dalam sistem rekomendasi film. Kolom yang dipilih terdiri dari show_id, yang merupakan ID unik untuk setiap film atau acara TV, title, yang berisi judul film atau acara, dan listed_in, yang mencakup genre atau kategori film tersebut. Setiap film atau acara bisa memiliki lebih dari satu genre. Dengan memilih kolom-kolom ini, dataset menjadi lebih terfokus pada elemen-elemen utama yang diperlukan untuk menghasilkan rekomendasi yang akurat, terutama berdasarkan genre yang sangat penting dalam menentukan kesamaan antar film atau acara TV."""

rec_netflix.loc[rec_netflix['listed_in'].str.contains('Sci-Fi', na=False), 'listed_in'] = rec_netflix['listed_in'].str.replace('Sci-Fi', 'scifi')
rec_netflix.head()

"""Setelah dilakukan pembersihan dan standarisasi genre dalam kolom **listed_in**, langkah selanjutnya adalah memastikan konsistensi format genre untuk memudahkan pemrosesan data. Proses ini penting karena dalam analisis teks atau perhitungan kesamaan, ketidakkonsistenan dalam penulisan genre (misalnya "Sci-Fi" menjadi "scifi" ) dapat mempengaruhi hasil pemrosesan dan perhitungan kesamaan antar item. Oleh karena itu, genre dengan format atau penulisan yang berbeda akan disesuaikan agar memiliki format yang lebih seragam, sehingga analisis selanjutnya menjadi lebih akurat dan konsisten."""

netflix_show_id = rec_netflix['show_id'].tolist()

netflix_title = rec_netflix['title'].tolist()

netflix_genre = rec_netflix['listed_in'].tolist()

"""Selanjutnya, kolom **show_id**, **title**, dan **listed_in** diubah menjadi list untuk memudahkan pemrosesan data menggunakan TfidfVectorizer dari scikit-learn. Dalam konteks ini, TfidfVectorizer membutuhkan input dalam bentuk list string, di mana setiap string mewakili genre atau kategori film secara individual. Proses ini memastikan bahwa setiap nilai dalam kolom-kolom tersebut dapat diproses secara efisien untuk analisis selanjutnya, terutama dalam perhitungan kesamaan antar item berdasarkan genre.

# Model Development - Content Based Filtering
"""

netflix_new = pd.DataFrame({
    'show_id': netflix_show_id,
    'title': netflix_title,
    'listed_in': netflix_genre
})

netflix_new.head()

"""## One Hot Encoding"""

# Membuat daftar genre unik
genre_list = []

for index in netflix_new.index:
    temp = netflix_new['listed_in'][index].split(',')
    for i in temp:
        if i.strip() not in genre_list:  # Tambahkan pengecekan agar genre tidak duplikat
            genre_list.append(i.strip())

# Membuat DataFrame untuk one-hot encoding
onehot_df = pd.DataFrame(0, index=netflix_new.index, columns=genre_list)

# Mengisi nilai 1 untuk genre yang sesuai
for index in netflix_new.index:
    temp = netflix_new['listed_in'][index].split(',')
    for i in temp:
        onehot_df.loc[index, i.strip()] = 1  # Menambahkan strip untuk menghilangkan spasi yang tidak diperlukan

# Menggabungkan DataFrame hasil one-hot encoding dengan DataFrame asli
netflix_new = pd.concat([netflix_new, onehot_df], axis=1)

# Menampilkan hasil
netflix_new.head()

"""Selanjutnya melalui proses one-hot encoding, di mana setiap kategori atau genre yang ada di kolom listed_in dikodekan dalam bentuk biner (0 atau 1). Setiap baris mewakili entri dalam dataset, seperti film atau acara TV, dan setiap kolom yang mewakili genre atau kategori menunjukkan apakah genre tersebut termasuk dalam entri tersebut. Proses ini mempermudah analisis data, seperti perhitungan kesamaan atau pengelompokan, dengan mengubah kategori menjadi format yang lebih mudah diproses secara matematis.

## TD-IDF Vectorizer
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Inisialisasi TfidfVectorizer
tfid = TfidfVectorizer()

# Melakukan perhitungan idf pada data genre
tfid.fit(netflix_new['listed_in'])

# Mapping array dari fitur index integer ke fitur nama
# Use get_feature_names_out() instead of get_feature_names()
tfid.get_feature_names_out()

"""Kode di atas menunjukkan penggunaan **TfidfVectorizer** dari pustaka `sklearn` untuk menghitung nilai **TF-IDF** pada data genre film yang terdapat dalam kolom **listed_in**. Dengan menginisialisasi objek `TfidfVectorizer`, kode ini menghitung **IDF (Inverse Document Frequency)** dari setiap genre dalam dataset, yang kemudian dikonversi menjadi vektor numerik. Fungsi `get_feature_names_out()` digunakan untuk mendapatkan daftar genre yang telah diproses, seperti **'action'**, **'comedy'**, **'documentaries'**, dan lainnya. Proses ini memungkinkan data teks diubah menjadi format numerik yang dapat digunakan untuk analisis lebih lanjut, seperti perhitungan kesamaan antar film berdasarkan genre."""

tfid_matrix = tfid.fit_transform(netflix_new['listed_in'])

tfid_matrix.shape

tfid_matrix.todense()

pd.DataFrame(
    tfid_matrix.todense(),
    columns=tfid.get_feature_names_out(),
    index=netflix_new.title
).sample(22, axis=1).sample(10, axis=0)

"""## Cosine Similarity"""

from sklearn.metrics.pairwise import cosine_similarity

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfid_matrix)
cosine_sim

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa title netflix
cosine_sim_df = pd.DataFrame(cosine_sim, index=netflix_new['title'], columns=netflix_new['title'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap netflix
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Tahap di atas menunjukkan perhitungan **cosine similarity** menggunakan matriks **TF-IDF** yang dihitung sebelumnya. **Cosine similarity** adalah ukuran kesamaan antara dua vektor teks berdasarkan sudut antar vektor tersebut. Hasil dari `cosine_similarity(tfid_matrix)` menghasilkan sebuah matriks yang menunjukkan tingkat kesamaan antara setiap pasangan item (misalnya, film atau acara TV) berdasarkan genre yang ada.

### Langkah-langkah yang dilakukan:

1. **Perhitungan Cosine Similarity**:
   Dengan menggunakan `cosine_similarity()` dari `sklearn.metrics.pairwise`, kesamaan antara setiap film dihitung berdasarkan matriks **TF-IDF** (`tfid_matrix`). Hasilnya adalah sebuah matriks berukuran (5185, 5185) yang menggambarkan seberapa mirip setiap film dengan yang lainnya.

2. **Membuat DataFrame**:
   Matriks cosine similarity kemudian diubah menjadi DataFrame dengan menggunakan `pd.DataFrame()`, di mana baris dan kolomnya berisi **title** dari film atau acara TV. Hal ini memudahkan untuk melihat kesamaan antara setiap item dengan lebih jelas.

3. **Melihat Matriks Cosine Similarity**:
   Matriks kesamaan ini ditampilkan sebagian dengan `sample()`, sehingga dapat dilihat seberapa mirip setiap judul film dengan judul lainnya berdasarkan genre.

## Euclidean Distance
"""

from sklearn.metrics.pairwise import euclidean_distances

euclidean_sim = euclidean_distances(tfid_matrix)
euclidean_sim

euclidean_sim_df = pd.DataFrame(euclidean_sim, index=netflix_new['title'], columns=netflix_new['title'])
print('Shape:', euclidean_sim_df.shape)

euclidean_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Tahap di atas menunjukkan perhitungan **Euclidean distance** menggunakan matriks **TF-IDF** yang dihitung sebelumnya. **Euclidean distance** adalah ukuran jarak antara dua vektor dalam ruang multidimensi, yang dihitung berdasarkan perbedaan nilai-nilai dalam vektor tersebut. Hasil dari `euclidean_distances(tfid_matrix)` menghasilkan sebuah matriks yang menunjukkan seberapa jauh jarak antara setiap pasangan item (misalnya, film atau acara TV) berdasarkan genre yang ada.

### Langkah-langkah yang dilakukan:

1. **Perhitungan Euclidean Distance**:
   Dengan menggunakan `euclidean_distances()` dari `sklearn.metrics.pairwise`, jarak antara setiap film dihitung berdasarkan matriks **TF-IDF** (`tfid_matrix`). Hasilnya adalah sebuah matriks berukuran (5185, 5185) yang menggambarkan jarak antara setiap film dengan film lainnya.

2. **Membuat DataFrame**:
   Matriks Euclidean distance kemudian diubah menjadi DataFrame dengan menggunakan `pd.DataFrame()`, di mana baris dan kolomnya berisi **title** dari film atau acara TV. Hal ini memudahkan untuk melihat jarak antara setiap item dengan lebih jelas.

3. **Melihat Matriks Euclidean Distance**:
   Matriks jarak ini ditampilkan sebagian dengan `sample()`, sehingga dapat dilihat seberapa jauh jarak antar judul film berdasarkan genre.

Hasil perhitungan ini memberikan insight tentang bagaimana jarak atau perbedaan antara film-film dalam dataset berdasarkan genre mereka. Film dengan jarak yang lebih kecil menunjukkan tingkat kesamaan yang lebih tinggi, sedangkan yang dengan jarak lebih besar memiliki lebih banyak perbedaan.

# Rekomendasi

## Rekomendasi (Cosine Similarity)
"""

def netflix_cosine(title_netflix, similarity_data=cosine_sim_df, items=netflix_new[['title', 'listed_in']], k=10):
    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,title_netflix].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop name agar title netflix yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(title_netflix, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

rec_netflix[rec_netflix.title.eq('Time to Dance')]

netflix_cosine('Time to Dance')

"""10 Rekomendasi film yang didapatkan dengan **Cosine Similarity** dari film Time to Dance dengan genre yang sama

## Rekomendasi (Euclidean Distance)
"""

def netflix_euclidean(title_netflix, similarity_data=euclidean_sim_df, items=netflix_new[['title', 'listed_in']], k=10):
    similarity_scores = similarity_data[title_netflix].to_numpy()

    closest_indices = similarity_scores.argsort()[:k]

    closest_netflixs = similarity_data.columns[closest_indices]

    closest_netflixs = closest_netflixs.drop(title_netflix, errors='ignore')

    if len(closest_netflixs) < k:
        additional_netflixs = similarity_data.columns[similarity_scores.argsort()[k:2*k]]
        closest_netflixs = closest_netflixs.append(additional_netflixs).drop_duplicates()

    result_euclidean = pd.DataFrame(closest_netflixs[:k], columns=['title'])

    result_euclidean = result_euclidean.merge(items, on='title', how='left')

    return result_euclidean.head(k)

rec_netflix[rec_netflix.title.eq('Time to Dance')]

netflix_euclidean('Time to Dance')

"""10 Rekomendasi film yang didapatkan dengan **Euclidean Distance** dari film Time to Dance dengan genre yang sama

## Precision Model
"""

relevant_netflixs = netflix[netflix['listed_in'].str.contains('Dramas') | netflix['listed_in'].str.contains('Romantic Movies')]
actual_relevant = relevant_netflixs['title'].tolist()

cosine_recommended = netflix_cosine('Time to Dance')['title'].tolist()  # 10 rekomendasi dengan Cosine Similarity
euclidean_recommended = netflix_euclidean('Everyday I Love You')['title'].tolist()  # 10 rekomendasi dengan Euclidean Distance

print("Cosine Similarity Recommends:", cosine_recommended)
print("Euclidean Distance Recommends:", euclidean_recommended)

def precision_at_k(recommended, actual, k=10):
    relevant_items = sum([1 for netflix in recommended[:k] if netflix in actual])
    precision = relevant_items / k if k > 0 else 0
    return precision

precision_cosine = precision_at_k(cosine_recommended, actual_relevant, k=10)
precision_euclidean = precision_at_k(euclidean_recommended, actual_relevant, k=10)

# Menampilkan hasil Precision dan Recall
print(f"Precision at k for Cosine Similarity: {precision_cosine:.2f}")
print(f"Precision at k for Euclidean Distance: {precision_euclidean:.2f}")

"""Output dari cell di atas menunjukkan hasil rekomendasi film menggunakan dua metode penghitungan kesamaan: **Cosine Similarity** dan **Euclidean Distance**. Berdasarkan genre, **Cosine Similarity** memberikan rekomendasi film yang serupa dengan film "Time to Dance", sementara **Euclidean Distance** memberikan rekomendasi berdasarkan jarak antara "Everyday I Love You" dan film lainnya. Hasil rekomendasi untuk kedua metode ini ditampilkan dalam bentuk daftar judul film yang paling mirip dengan film yang diberikan. Selanjutnya, **Precision at k** dihitung untuk kedua metode tersebut, yang mengukur seberapa banyak film relevan yang ditemukan dalam 10 rekomendasi pertama. Precision untuk **Cosine Similarity** dan **Euclidean Distance** dihitung dan ditampilkan dalam format dua angka desimal, memberikan gambaran tentang seberapa efektif kedua metode dalam merekomendasikan film yang relevan berdasarkan genre.

"""